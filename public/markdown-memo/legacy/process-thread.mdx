---
title: "Process & Thread"
description: ""
tags: ["CS"]
date: "2023-12-05"
thumbnail: "/markdown-memo/legacy/images/933503f4-56a5-41f3-8c14-a999badcce2f.png"
---


<!-- Table of Contents -->

# Process & Thread

운영체제로부터 자원을 할당받은 작업의 단위를 **Process**, **Process**가 할당받은 자원을 이용하는 실행 흐름의 단위를 **Thread **라고 한다.

# Process

컴퓨터에서 실행할 수 있는 파일인 프로그램 (Program)을 실행하면 운영체제로부터 이 프로그램을 실행하기 위한 자원을 할당받는다.

즉, 프로세스는 실행되어 작업 중인 컴퓨터 프로그램이다.

# Thread

하나의 프로세스 안에서 동시에 진행되는 작업, 실행 흐름의 단위

> 💡 크롬 브라우저에서 동영상 시청, 웹 서핑, 파일 다운로드가 동시에 가능한 이유도 하나의 프로세스 안에서 여러 스레드(멀티 스레드)가 작동하기 때문이다.

일반적으로 하나의 프로그램은 하나 이상의 프로세스를 가지고 있고, 하나의 프로세스는 반드시 하나 이상의 스레드를 가진다.


# 프로세스의 자원 구조

프로세스가 만들어지면 다음 메모리 영역으로 구성되어 할당 받게 된다.

![](/markdown-memo/legacy/images/933503f4-56a5-41f3-8c14-a999badcce2f.png)

## 코드 영역 (Text/Code)

프로그래머가 작성한 코드가 CPU가 해석가능한 기계어 형태로 저장되어 있다.

## 데이터 영역 (Data)

코드가 실행되면서 사용하는 전역 변수나 각종 데이터들이 모여있다. **.data**, **.rodata**, **.bss**** **영역으로 나뉘어 진다.

- .data : 전역 변수 또는 static 변수 등 프로그램이 사용하는 데이터를 저장
- .bss : 초기값 없는 전역 변수, static 변수가 저장
- .rodata : const 같은 상수 키워드가 선언된 변수나 문자열 상수가 저장
## 스택 영역 (Stack)

지역 변수와 같은 호출한 함수가 종료되면 되돌아올 임시적인 자료를 저장하는 독립적인 공간이다. Stack은 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸한다.

만약 Stack 영역을 초과하면 Stack overflow 에러가 발생한다.

## 힙 영역 (Heap)

생성자, 인스턴스와 같은 동적으로 할당되는 데이터들을 위해 존재하는 공간이다. 사용자에 의해 메모리 공간이 동적으로 할당되고 해제된다.

# 스레드의 자원 공유

스레드는 프로세스가 할당 받은 자원을 이용하는 실행 흐름의 단위로서 스레드가 여러개 있으면 파일 다운과 웹 서핑을 동시에 할 수 있게 해준다.

스레드는 프로세스의 4가지 영역 중 **Stack 만 할당받아 복사**하고 나머지 3가지 영역은 다른 스레드들과 공유된다.

> 💡 Stack은 함수 호출 시 전달되는 인자, 되돌아올 주소값, 함수 내에서 선언하는 변수 등을 저장하는 영역이기 떄문에 독립적인 스택을 가졌다는 것은 독립적인 함수 호출이 가능하다는 뜻.

# 프로세스의 자원 공유

일반적으로 프로세스는 서로 다른 주소 공간에서 실행되기 때문에 프로세스 간의 변수나 자료구조에 접근할 수 없다.

그러나 특별한 방법을 사용하여 다른 프로세스의 정보를 가져올 수 있다.

1. IPC (Inter-Process Communication) 사용
1. LPC (Local inter-Process Communication) 사용
1. 별도로 공유 메모리를 만들어서 정보를 주고받도록 설정
# 프로세스 & 스레드의 동시 실행 원리

CPU 한 개는 여러 개의 코어를 가질 수 있는데, 코어는 기계어를 메모리에서 뽑아 해석하고 실행하는 반도체 유닛을 말한다.

4코어 8스레드 CPU 라는 것은 물리적 코어 하나가 논리적 코어인 스레드 2개 이상을 동시에 실행가능하다는 뜻이다.

앞서 프로그램 실행시 한 개 이상의 프로세스가 생성된다고 했었는데 우리는 컴퓨터를 사용할 때 수십, 수백개의 프로그램을 사용한다.

CPU는 8개의 스레드로 많은 수의 프로세스들을 처리하기 위해서 **병렬성 (Parallelism)**** **과 **동시성 (Concurrency)** 이라는 개념을 사용한다.

## 병렬성 (Parallelism)

여러개의 코어와 스레드를 사용하여 작업을 동시 수행하는 것을 말한다.

## 동시성 (Concurrency)

병렬성과는 달리 동시 실행하는 것이 아닌 동시에 실행하는 것처럼 보이게 한다. 작업들을 실행할 때 이를 잘게 나누어 아주 조금씩만 작업을 수행하고 다음 작업으로 넘어가는 식으로 동작한다.

이렇게 진행 중인 작업들을 번갈아 바꾸는 것을 **Context Switching** 이라고 한다.

## 동시성이 필요한 이유?

1. **하드웨어적 한계**
1. **논리적 효율**
# 프로세스 & 스레드의 생명 주기

## 프로세스 스케쥴링

OS에서 CPU를 사용할 수 있는 프로세스를 선택하고, CPU를 할당하는 작업을 프로세스 스케쥴링이라고 한다.

이는 프로세스의 우선순위, 작업량 등을 고려하여 효율적으로 배치하여, 이를 통해 CPU를 효율적으로 사용하여 시스템의 전반적인 성능을 향상시킨다.

대표적인 스케쥴링 알고리즘은 다음과 같다.

- FCFS (First-Come, First-Served)
- SJF (Shortest-Job-First)
- RR (Round-Robin)
- Multilevel Queue
## 프로세스 상태

프로세스가 실행되는 동안 일반적으로 5가지의 상태를 가지게 된다.

- 생성 (new) - 프로세스가 생성되고 아직 준비가 되지 않은 상태
- 준비 (ready) - 프로세스가 실행을 위해 기다리는 상태. CPU를 할당받을 수 있는 상태이며, 언제든지 실행될 준비가 되어 있다.
- 실행 (running) - 프로세스가 CPU를 할당받아 실행되는 상태
- 대기 (waiting) - 프로세스가 특정 이벤트 (입출력 요청 등)가 발생하여 대기하는 상태. CPU를 할당받지 못하며, 이벤트가 발생하여 다시 ready 상태로 전환될 때까지 대기한다.
- 종료 (terminated) - 프로세스가 실행을 완료하고 종료된 상태. 더 이상 실행될 수 없으며, 메모리에서 제거되게 된다.
### 프로세스 상태 전이

프로세스 상태 전이는 스케쥴링 알고리즘에 의해 실행된다.

![](/markdown-memo/legacy/images/0232bfac-9817-4090-863c-3827f5458173.png)

- Admitted (new → ready) - 프로세스 생성을 승인 받음
- Dispatch (ready → running) - 준비 상태에 있는 여러 프로세스 중 하나가 스케쥴러에 의해 실행됨
- Interrupt (running → ready) - Timeout, 예기치 않은 이벤트가 발생하여 현재 실행 중인 프로세스를 준비 상태로 전환하고, 해당 작업을 먼저 처리
- I/O or event wait (running → waiting) - 실행 중인 프로세스가 입출력이나 이벤트를 처리해야 하는 경우, 입출력이나 이벤트가 끝날 때까지 대기 상태로 전환
- I/O or event completion (waiting → ready) - 입출력이나 이벤트가 모두 끝난 프로세스를 다시 준비 상태로 만들어 스케쥴러에 의해 선택될 수 있는 상태로 전환

## 프로세스 컨텍스트 스위칭

CPU 자원의 한계로 여러 개의 프로세스를 실행하기 위해서 앞서 동시성에서 언급했듯이 **프로세스를 번갈아가며 실행**한다고 말했다.

컨텍스트 스위칭은 동작 중인 프로세서가 대기를 하며 해당 프로세스의 상태(context)를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세서의 상태를 복구하는 작업을 말한다.

### PCB (Process Control Block)

PCB는 OS에서 프로세스를 관리하기 위해 해당 프로세스의 정보를 담고 있는 자료 구조이다.

프로세스 컨텍스트 스위칭을 하기 위해 기존 프로세스의 상태를 어딘가에 저장해야 다음에 똑같은 작업을 할 수 있으므로, PCB는 프로세스 스케쥴링을 하기 위해 **프로세스에 관한 모든 정보를 저장하는 임시 저장소**이다.

![](/markdown-memo/legacy/images/399f482b-8c9d-420f-930d-6b61a86c9b2f.png)

PCB내에는 일반적으로 다음과 같은 정보가 담긴다.

![](/markdown-memo/legacy/images/bd25f81f-66a1-47d9-b1ff-f0252f13e129.png)

- 포인터 (Pointer) : 프로세스의 현재 위치를 저장하는 포인터 정보
- 프로세스 상태 (Process State) : 프로세스의 각 [상태](/241f04d625eb462ebc61b5cdd62fff87#cd52571b7aca424e9aaa0fac8d87a84b)를 저장 
- 프로세스 아이디 (Process ID, PID) : 프로세스 식별자를 지정하는 고유한 ID
- 프로그램 카운터 (Program Counter) : 프로세스를 위해 실행된 다음 명령어의 주소를 포함하는 카운터를 저장
- 레지스터 (Register) : 누산기, 베이스, 레지스터 및 범용 레지스터를 포함하는 CPU 레지스터에 있는 정보
- 메모리 제한 (Memory Limits) : 운영 체제에서 사용하는 메모리 관리 시스템에 대한 정보
- 열린 파일 목록 (List of open files) : 프로세스를 위한 열린 파일 목록

### Context Switching 과정

두 개의 프로세스 간의 컨텍스트 스위치 과정을 그림으로 표현하면 다음과 같다.

![](/markdown-memo/legacy/images/40cb20b0-495a-4336-9022-71355d2a5ab8.png)

1. CPU는 Process P1을 실행한다. (CPU State → Executing)
1. 일정 시간이 지나 Interrupt 또는 System call이 발생한다 (CPU State → Idle)
1. 현재 실행 중인 Process P1의 상태를 PCB1에 저장한다.
1. 다음으로 실행할 Process P2을 선택한다. (CPU 스케쥴링)
1. Process P2의 상태를 PCB2에서 불러온다.
1. CPU는 Process 2를 실행한다. (CPU State → Executing)
1. 일정 시간이 지나 Interrupt 또는 System call이 발생한다. (CPU State → Idle)
1. 현재 실행 중인 Process P2의 상태를 PCB2에 저장한다.
1. 다시 Process P1의 상태를 실행할 차례가 된다. (CPU 스케쥴링)
1. Process P1의 상태를 PCB1에서 불러온다.
1. CPU는 Process P1을 중간 시점부터 실행한다. (CPU State → Executing)

### Context Switching Overhead

컨텍스트 스위칭 과정은 빠른 반응성과 동시성을 제공하지만, 스위칭 과정에서 프로세스의 상태, 레지스터 값 등이 저장되고 불러오는 과정에서 시스템에 부담을 주게된다.

컨텍스트 스위칭 과정을 보면 다음 프로세스로 전환될 때 CPU가 Idle상태로 대기하는 간극이 있는 것을 볼 수 있다. 이 간극이 컨텍스트 스위칭 오버헤드이다.

이는 다음과 같은 행위에 의해서 발생된다.

- PCB 저장 및 복원 비용
- CPU 캐시 메모리 무효화에 따른 비용
- 프로세스 스케쥴링 비
# References

[https://inpa.tistory.com/entry/👩‍💻-프로세스-⚔️-쓰레드-차이#한눈에_이해하는_프로세스__스레드_개념](https://inpa.tistory.com/entry/👩‍💻-프로세스-⚔️-쓰레드-차이#한눈에_이해하는_프로세스__스레드_개념)

