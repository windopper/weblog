---
title: "세그먼트 트리"
description: ""
tags: ["Algorithm"]
date: "2023-02-11"
thumbnail: ""
---

# 개요

세그먼트 트리는 **여러 개의 데이터가 연속적으로 존재할 때 특정한 범위의 데이터의 합을 구하는 방법**에 관한 것이다.


우리는 배열에서 특정 구간의 합을 구하기 위해서 일반적으로 범위에 속하는 수를 하나씩 더하여 계산한다.

이는 매우 단순하지만 데이터의 개수가 N개 있다고 가정하면 시간 복잡도는 O(N)이 나온다.

하지만 세그먼트 트리를 사용하여 시간 복잡도 O(log N) 으로 구간 합을 구할 수 있어 선형적인 계산방식보다 더 빠르다.


# 트리 초기화 하기

어떤 한 배열을 `arr = [5, 4, 3, 2, 1]` 이라고 초기화 해보자


# 구현

```python
import sys
input = sys.stdin.readline

n, m, k = map(int, input().split())
segment_tree = [0] * (n*4)
arr = []

"""
트리 초기화 함수
start, end는 트리의 범위로 같다면 리프노드를 의미한다.
"""
def init(start, end, index):
		# 같다면 리프노드이다. 리프노드에는 우리가 배열에 저장했던 수를 놓는다
    if start == end:
        segment_tree[index] = arr[start-1]
        return segment_tree[index]
		
		# 아직 리프노드에 도달하지 않았다면 범위를 쪼개 리프노드에 도달할 때 까지 진행한다.
		# 왼쪽 아래 노드는 현재 인덱스에서 2를 곱한 것이고
		# 오른쪽 아래 노드는 현재 인덱스에서 2를 곱하고 1을 더한 것이다.
    mid = (start + end) // 2
    segment_tree[index] = init(start, mid, index*2) + init(mid+1, end, index*2+1)
    return segment_tree[index]

"""
트리에서 값 찾기
start, end는 트리의 범위, index는 노드 고유번호, left, right는 탐색 범위이다.
"""
def find(start, end, index, left, right):
		# 트리의 범위에 속하지 않는 다면 0을 반환
    if start > right or end < left:
        return 0
		# 트리의 범위에 속한다면 이는 트리의 노드에 저장된 구간합이 있다는 뜻으로
		# 이를 반환한다. 
    if start >= left and end <= right:
        return segment_tree[index]
    
		# 트리의 범위에 부분적으로 속한다면 범위를 쪼개 완전히 속하는 노드를 찾는다.
    mid = (start + end) // 2
    sub_sum = find(start, mid, index*2, left, right) + find(mid+1, end, index*2+1, left, right)
    return sub_sum

def update(start, end, index, update_idx, update_data):
    if start > update_idx or end < update_idx:
        return
    
    segment_tree[index] += update_data

    if start == end:
        return

    mid = (start + end) // 2
    update(start, mid, index*2, update_idx, update_data)
    update(mid+1, end, index*2+1, update_idx, update_data)

for _ in range(n):
    arr.append(int(input()))

init(1, n, 1)

for _ in range(m+k):
    a, b, c = map(int, input().split())
    if a == 1:
        temp = c - arr[b-1]
        arr[b-1] = c
        update(1, n, 1, b, temp)
    else:
        print(find(1, n, 1, b, c))
```


# 유형

[https://www.acmicpc.net/problem/1517](https://www.acmicpc.net/problem/1517)

단순하게 접근하면 안되는 문제. 사실 이 문제는 Inverse Counting이라고 불리는 유명한 문제다. 핵심은 주어진 수열을 정렬하고 따로 저장했던 원래의 위치를 기준으로 쿼리를 전달해야 된다.

한번에 떠올리기 어려운 아이디어, 그러나 다방면으로 사용된다. 알아두면 좋음


[https://www.acmicpc.net/problem/7578](https://www.acmicpc.net/problem/7578)

1517번: 버블 소트와 매우 유사한 문제. 교차하는 케이블 쌍의 개수를 Inverse Counting 문제를 바꾸어 풀 수 있다.


[https://www.acmicpc.net/problem/2517](https://www.acmicpc.net/problem/2517)

버블소트, 공장 문제와 비슷하지만 조금 더 어렵다. 값 압축을 기반으로 순차적인 쿼리를 날리면 되는 문제

# 심화

## 펜윅 트리

[https://www.acmicpc.net/blog/view/21](https://www.acmicpc.net/blog/view/21)


- 머지 소트 트리
