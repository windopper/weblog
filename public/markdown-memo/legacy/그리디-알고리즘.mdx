---
title: "그리디 알고리즘"
description: ""
tags: ["Algorithm"]
date: "2023-04-01"
thumbnail: ""
---

# 그리디 알고리즘

그리디 알고리즘은 최적해를 구하는 상황에서 사용되는 알고리즘입니다. 최적해란 문제의 조건을 만족시키면서, 최대 또는 최소의 값을 가지는 해를 의미합니다.

그리디 알고리즘은 매 순간 최적이라고 생각되는 것을 선택해 나가면서 문제를 해결합니다. 하지만 이러한 선택들이 모여 최적해를 만들어내지 않을 수 있습니다. 따라서 그리디 알고리즘은 항상 최적해를 보장하지는 않습니다.

하지만 그리디 알고리즘은 다른 알고리즘에 비해 구현이 간단하며 빠른 속도를 보입니다. 그리디 알고리즘은 대표적으로 거스름돈 문제, 배낭 문제 등에서 사용됩니다.

그리디 알고리즘은 문제의 조건을 잘 파악하고, 적절한 선택 기준을 세우는 것이 중요합니다. 이러한 기준을 통해 최적해에 가까운 값을 구할 수 있습니다.


# 문제 접근법

그리디 알고리즘은 항상 최적의 선택을 한다는 점에서 매우 직관적인 알고리즘이지만 어떠한 방식으로 접근해야 할지 난감한 상황이 있습니다.

그리디 문제에서의 일반적인 해결 절차는 다음과 같습니다.

1. 현재 상태에서의 최적의 해답을 선택
1. 선택된 해가 문제의 조건을 만족하는지 검사
1. 원래의 문제가 해결되었는지 검사하고, 해결되지 않았다면 선택 절차로 돌아가 반복

또한, 그리디 알고리즘을 적용하기 위한 문제의 조건은 다음과 같습니다.

1. 탐욕스러운 선택 조건 - **앞의 선택이 이후의 선택에 영향을 주지 않아야 한다.**
1. 최적 부분 구조 조건 - **문제에 대한 최적해가 부분문제에 대해서도 최적해를 보장해야 한다.**
> 💡 최적 부분 구조 조건은 동적계획법을 적용하기 위한 문제 조건에도 속합니다. 그래서  그리디 알고리즘으로 풀 수 있는 문제들은 동적계획법을 통해 풀 수 있습니다.

> ⛔ 그리디 알고리즘으로 풀 수 있는 문제들을 동적계획법을 통해 풀지 않는 이유는 동적계획법에서 사용되는 메모리의 양과 계산 속도가 그리디 알고리즘에 비해서 굉장히 느리기 때문입니다.

# 그리디 해결 테크닉

1. 정방향으로 그리디 한 해법을 찾기 어려울 때 역방향으로 시도하면 문제가 쉬워지는 경우 가 있습니다.
1. 그리디 유형 중에 우선순위 큐를 사용하는 유형 또한 존재합니다. 일단 집어넣고 나중에 조건에 따라 이전에 선택했던 값을 제거하여 쉽게 해결하는 경우가 있습니다.
1. 일부 조건을 강제하여 문제를 쉽게 만든 후 나머지 부분 문제들을 그리디하게 해결하는 방법이 있습니다.
# 예제들

[https://www.acmicpc.net/problem/1541](https://www.acmicpc.net/problem/1541)

그리디 알고리즘 기본 문제 중 하나. 문제를 통해 직관적으로 풀이를 떠올릴 수 있습니다.


[https://www.acmicpc.net/problem/12904](https://www.acmicpc.net/problem/12904)

역방향으로 시도했을 떄 문제의 난이도가 급격하게 쉬워지는 유형입니다.


[https://www.acmicpc.net/problem/12970](https://www.acmicpc.net/problem/12970)

실수하기 쉬운 문제, inversion counting의 개념을 알고 있으면 풀기 쉽다고는 하는데… 굳이 몰라도 충분히 고민하여 해결가능한 문제입니다.


[https://www.acmicpc.net/problem/2109](https://www.acmicpc.net/problem/2109)

정방향으로 풀면 힘든 유형 중 하나입니다. 역방향으로 풀어도 되고, 정방향으로 풀고 싶다면 우선순위 큐를 이용하여 이전에 선택했던 강연을 제거하는 테크닉이 필요합니다.

그리디 알고리즘에서 많이 나오는 유형 중 하나로 비슷한 유형에 대한 대략적인 해결법을 알고 있다면 접근이 쉽습니다.


[https://www.acmicpc.net/problem/13904](https://www.acmicpc.net/problem/13904)

2109와 거의 동일한 문제입니다. 우선순위 큐 + 그리디의 강력함을 볼 수 있습니다.


[https://www.acmicpc.net/problem/1781](https://www.acmicpc.net/problem/1781)

2109, 13904과 비슷한 문제. 역방향으로도 해결이 가능하다.


[https://www.acmicpc.net/problem/8980](https://www.acmicpc.net/problem/8980)

정렬 기준은 종료 시간 기준이지만 이것이 그리디하게 성립되는 이유를 증명하기 어렵습니다. 또한 각 마을을 지날 때 마다 트럭이 보유하고 있는 상자의 수를 배열로 표현하는 아이디어가 쉽게 떠오르지 않습니다.


[https://www.acmicpc.net/problem/1826](https://www.acmicpc.net/problem/1826)

연료를 다 쓸떄까지 이동하였을 때 연료가 부족하다면 이때까지 지나온 주유소에 대하여 가장 많은 연료를 주는 것을 받는다.

우선순위 큐로 풀 수도 있었으나 단순하게 정렬로 해결


## 제약 조건 강제

[https://www.acmicpc.net/problem/2138](https://www.acmicpc.net/problem/2138)

1번 스위치 혹은 N번 스위치를 누르는 경우를 분리하여 총 4번의 반복문을 돌린 후 가장 적게 누른 스위치 횟수를 출력하면 됩니다.


## LIS 아이디어 사용

[https://www.acmicpc.net/problem/7570](https://www.acmicpc.net/problem/7570)


